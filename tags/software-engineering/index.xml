<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Engineering on Programming Philosophy</title>
    <link>/tags/software-engineering/</link>
    <description>Recent content in Software Engineering on Programming Philosophy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Oct 2018 19:34:21 +0000</lastBuildDate>
    
	<atom:link href="/tags/software-engineering/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rob Pike On Complexity</title>
      <link>/posts/2018-10-05_rob-pike-on-complexity/</link>
      <pubDate>Fri, 05 Oct 2018 19:34:21 +0000</pubDate>
      
      <guid>/posts/2018-10-05_rob-pike-on-complexity/</guid>
      <description>“assorted electric cables” by John Carlisle on Unsplash
The following is an excerpt from Notes on Programming in C by Rob Pike &amp;gt; Complexity&amp;gt; Most programs are too complicated — that is, more complex than they need to be to solve their problems efficiently. Why? Mostly it’s because of bad design, but I will skip that issue here because it’s a big one. But programs are often complicated at the microscopic level, and that is something I can address here.</description>
    </item>
    
    <item>
      <title>Code As Design</title>
      <link>/posts/2018-09-03_code-as-design/</link>
      <pubDate>Mon, 03 Sep 2018 12:21:00 +0000</pubDate>
      
      <guid>/posts/2018-09-03_code-as-design/</guid>
      <description>“worm&amp;#39;s eye-view photography of ceiling” by Joshua Sortino on Unsplash
In 1992 Jack Reeves published an essay What Is Software Design? in the C++ Journal.
His basic premise is: “that final source code is the real software design.”
He goes on to explain… &amp;gt; “The final goal of any engineering activity is some type of documentation. When a design effort is complete, the design documentation is turned over to the manufacturing team.</description>
    </item>
    
    <item>
      <title>Engineering for the Long Game</title>
      <link>/posts/2018-08-23_engineering-for-the-long-game/</link>
      <pubDate>Thu, 23 Aug 2018 22:27:45 +0000</pubDate>
      
      <guid>/posts/2018-08-23_engineering-for-the-long-game/</guid>
      <description>Photo by Jon Tyson on Unsplash
Astrid Atkinson from Google speaking about Engineering for the Long Game at O’Reilly Velocity conference.
Here are some points that stuck out to me:
 Your job is not to limit growth. When you’re trying to keep complexity in check, one of the worst things you can do is say “You can’t launch this, it’s too complex, it’s going to make things worse” You want to be enabling all the growth the product can provide.</description>
    </item>
    
    <item>
      <title>The Commandments of Good Code according to Zach™</title>
      <link>/posts/2018-05-02_commandments-of-good-code-according-to-zach/</link>
      <pubDate>Wed, 02 May 2018 13:01:01 +0000</pubDate>
      
      <guid>/posts/2018-05-02_commandments-of-good-code-according-to-zach/</guid>
      <description>Photo by Adrian Curiel on Unsplash
The Commandments of Good Code according to Zach™
 Treat your code the way you want other’s code to treat you All (ok most) programming languages are simultaneously good and bad Good code is easily read and understood, in part and in whole Good code has a well thought out layout &amp;amp; architecture to make managing state obvious Good code doesn’t reinvent the wheel, it stands on the shoulders of giants Don’t cross the streams!</description>
    </item>
    
    <item>
      <title>The 10 Commandments of Egoless Programming</title>
      <link>/posts/2018-04-04_10-commandments-of-egoless-programming/</link>
      <pubDate>Wed, 04 Apr 2018 12:31:00 +0000</pubDate>
      
      <guid>/posts/2018-04-04_10-commandments-of-egoless-programming/</guid>
      <description>Photo by Karl Fredrickson on Unsplash
From The Psychology of Computer Programming by Jerry Weinberg:
1. Understand and accept that you will make mistakes. The point is to find them early, before they make it into production. Fortunately, except for the few of us developing rocket guidance software at JPL, mistakes are rarely fatal in our industry, so we can, and should, learn, laugh, and move on.
2. You are not your code.</description>
    </item>
    
    <item>
      <title>A Critique of the Remote Procedure Call Paradigm</title>
      <link>/posts/2018-04-03_critique-of-the-remote-procedure-call-paradigm/</link>
      <pubDate>Tue, 03 Apr 2018 21:31:08 +0000</pubDate>
      
      <guid>/posts/2018-04-03_critique-of-the-remote-procedure-call-paradigm/</guid>
      <description>“Fans and wires on the back of a computer server” by Thomas Kvistholt on Unsplash
I have long disliked RPC, especially since I built a very messy XML-RPC/PHP system many years ago. This paper would have helped me out immensely.
A Critique of the Remote Procedure Call Paradigm by Andrew S. Tanenbaum and Robbert van Renesse &amp;gt; We propose the following test for a general-purpose RPC system. Imagine that two programmers are working on a project.</description>
    </item>
    
    <item>
      <title>Don’t Be The Mad Bomber</title>
      <link>/posts/2018-04-02_dont-be-the-mad-bomber/</link>
      <pubDate>Mon, 02 Apr 2018 17:37:53 +0000</pubDate>
      
      <guid>/posts/2018-04-02_dont-be-the-mad-bomber/</guid>
      <description>“Two men working back-to-back outside with a brick wall background” by rawpixel.com on Unsplash
From “The Psychology of Computer Programming” by Gerald M. Weinberg
Jerry tells a great story about the perils of personality and how two different programmers were affecting the entire department: &amp;gt; _Personality, being the totality of factors contributing to our individuality, is displayed in everything we do or say. In particular, it is reflected in our programs, and, even more particularly, in how those programs look to the machine operators.</description>
    </item>
    
    <item>
      <title>How recursion got into programming: a comedy of errors</title>
      <link>/posts/2018-03-08_how-recursion-got-into-programming-a-comedy-of-errors/</link>
      <pubDate>Thu, 08 Mar 2018 17:02:51 +0000</pubDate>
      
      <guid>/posts/2018-03-08_how-recursion-got-into-programming-a-comedy-of-errors/</guid>
      <description>Photo by Dan Cook on Unsplash
Hat tip to the O’Reilly Programming Newsletter for this one.
How recursion got into programming: a comedy of errors by Maarten van Emden &amp;gt; By now it is difficult to imagine that once there was a time when the utility, and even the possibility, of recursion in programming was in doubt. Yet that was true of the programming community around 1960. Even the committee that was to create Algol 60 was divided on the issue.</description>
    </item>
    
    <item>
      <title>“The Best Programming Advice I Ever Got”</title>
      <link>/posts/2018-03-07_best-programming-advice-i-ever-got/</link>
      <pubDate>Wed, 07 Mar 2018 23:12:49 +0000</pubDate>
      
      <guid>/posts/2018-03-07_best-programming-advice-i-ever-got/</guid>
      <description>“Silhouette of two people in hoodies sitting under a tree and watching a pink sunset” by Harli Marten on Unsplash
Andrei Alexandrescu writes in an article to InformIT: &amp;gt; Most notably, learning how to learn is more important than learning anything else. If you know how to learn, you’ll reduce inertia and emotional investment in any particular niche, so you’re likely to make better decisions when choosing what to best work on.</description>
    </item>
    
  </channel>
</rss>